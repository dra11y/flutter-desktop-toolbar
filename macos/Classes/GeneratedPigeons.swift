// Autogenerated from Pigeon (v4.2.5), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif


/// Generated class from Pigeon.

enum GroupSelectionMode: Int {
  case single = 0
  case multiple = 1
  case momentary = 2
}

enum ToolbarSpace: Int {
  case single = 0
  case flexible = 1
}

///Generated class from Pigeon that represents data sent in messages.
struct ToolbarGroup {
  var items: [ToolbarItem?]
  var selectionMode: GroupSelectionMode
  var leadingSpace: ToolbarSpace? = nil
  var trailingSpace: ToolbarSpace? = nil
  var isCenterItem: Bool? = nil
  var paletteLabel: String? = nil

  static func fromMap(_ map: [String: Any?]) -> ToolbarGroup? {
    let items = map["items"] as! [ToolbarItem?]
    let selectionMode = GroupSelectionMode(rawValue: map["selectionMode"] as! Int)!
    var leadingSpace: ToolbarSpace? = nil
    if let leadingSpaceRawValue = map["leadingSpace"] as? Int {
      leadingSpace = ToolbarSpace(rawValue: leadingSpaceRawValue)
    }
    var trailingSpace: ToolbarSpace? = nil
    if let trailingSpaceRawValue = map["trailingSpace"] as? Int {
      trailingSpace = ToolbarSpace(rawValue: trailingSpaceRawValue)
    }
    let isCenterItem = map["isCenterItem"] as? Bool 
    let paletteLabel = map["paletteLabel"] as? String 

    return ToolbarGroup(
      items: items,
      selectionMode: selectionMode,
      leadingSpace: leadingSpace,
      trailingSpace: trailingSpace,
      isCenterItem: isCenterItem,
      paletteLabel: paletteLabel
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "items": items,
      "selectionMode": selectionMode.rawValue,
      "leadingSpace": leadingSpace?.rawValue,
      "trailingSpace": trailingSpace?.rawValue,
      "isCenterItem": isCenterItem,
      "paletteLabel": paletteLabel
    ]
  }
}

///Generated class from Pigeon that represents data sent in messages.
struct ToolbarItem {
  var title: String
  var iconData: ToolbarItemIconData
  var leadingSpace: ToolbarSpace? = nil
  var trailingSpace: ToolbarSpace? = nil
  var isCenterItem: Bool? = nil
  var isSelected: Bool? = nil

  static func fromMap(_ map: [String: Any?]) -> ToolbarItem? {
    let title = map["title"] as! String
    let iconData = ToolbarItemIconData.fromMap(map["iconData"] as! [String: Any?])!
    var leadingSpace: ToolbarSpace? = nil
    if let leadingSpaceRawValue = map["leadingSpace"] as? Int {
      leadingSpace = ToolbarSpace(rawValue: leadingSpaceRawValue)
    }
    var trailingSpace: ToolbarSpace? = nil
    if let trailingSpaceRawValue = map["trailingSpace"] as? Int {
      trailingSpace = ToolbarSpace(rawValue: trailingSpaceRawValue)
    }
    let isCenterItem = map["isCenterItem"] as? Bool 
    let isSelected = map["isSelected"] as? Bool 

    return ToolbarItem(
      title: title,
      iconData: iconData,
      leadingSpace: leadingSpace,
      trailingSpace: trailingSpace,
      isCenterItem: isCenterItem,
      isSelected: isSelected
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "title": title,
      "iconData": iconData.toMap(),
      "leadingSpace": leadingSpace?.rawValue,
      "trailingSpace": trailingSpace?.rawValue,
      "isCenterItem": isCenterItem,
      "isSelected": isSelected
    ]
  }
}

///Generated class from Pigeon that represents data sent in messages.
struct SelectedToolbarItem {
  var index: Int32
  var item: ToolbarItem
  var group: ToolbarGroup? = nil

  static func fromMap(_ map: [String: Any?]) -> SelectedToolbarItem? {
    let index = map["index"] as! Int32
    let item = ToolbarItem.fromMap(map["item"] as! [String: Any?])!
    var group: ToolbarGroup? = nil
    if let groupMap = map["group"] as? [String: Any?] {
      group = ToolbarGroup.fromMap(groupMap)
    }

    return SelectedToolbarItem(
      index: index,
      item: item,
      group: group
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "index": index,
      "item": item.toMap(),
      "group": group?.toMap()
    ]
  }
}

///Generated class from Pigeon that represents data sent in messages.
struct ToolbarItemIconData {
  var codePoint: Int32? = nil
  var fontFamily: String? = nil

  static func fromMap(_ map: [String: Any?]) -> ToolbarItemIconData? {
    let codePoint = map["codePoint"] as? Int32 
    let fontFamily = map["fontFamily"] as? String 

    return ToolbarItemIconData(
      codePoint: codePoint,
      fontFamily: fontFamily
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "codePoint": codePoint,
      "fontFamily": fontFamily
    ]
  }
}
private class ToolbarFlutterApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return SelectedToolbarItem.fromMap(self.readValue() as! [String: Any])      
      case 129:
        return ToolbarGroup.fromMap(self.readValue() as! [String: Any])      
      case 130:
        return ToolbarItem.fromMap(self.readValue() as! [String: Any])      
      case 131:
        return ToolbarItem.fromMap(self.readValue() as! [String: Any])      
      case 132:
        return ToolbarItemIconData.fromMap(self.readValue() as! [String: Any])      
      default:
        return super.readValue(ofType: type)
      
    }
  }
}
private class ToolbarFlutterApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? SelectedToolbarItem {
      super.writeByte(128)
      super.writeValue(value.toMap())
    } else if let value = value as? ToolbarGroup {
      super.writeByte(129)
      super.writeValue(value.toMap())
    } else if let value = value as? ToolbarItem {
      super.writeByte(130)
      super.writeValue(value.toMap())
    } else if let value = value as? ToolbarItem {
      super.writeByte(131)
      super.writeValue(value.toMap())
    } else if let value = value as? ToolbarItemIconData {
      super.writeByte(132)
      super.writeValue(value.toMap())
    } else {
      super.writeValue(value)
    }
  }
}

private class ToolbarFlutterApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return ToolbarFlutterApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return ToolbarFlutterApiCodecWriter(data: data)
  }
}

class ToolbarFlutterApiCodec: FlutterStandardMessageCodec {
  static let shared = ToolbarFlutterApiCodec(readerWriter: ToolbarFlutterApiCodecReaderWriter())
}

///Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class ToolbarFlutterApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return ToolbarFlutterApiCodec.shared
  }
  func didSelectItem(item itemArg: SelectedToolbarItem, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.ToolbarFlutterApi.didSelectItem", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([itemArg]) { _ in
      completion()
    }
  }
}
private class ToolbarHostApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return SelectedToolbarItem.fromMap(self.readValue() as! [String: Any])      
      case 129:
        return ToolbarGroup.fromMap(self.readValue() as! [String: Any])      
      case 130:
        return ToolbarItem.fromMap(self.readValue() as! [String: Any])      
      case 131:
        return ToolbarItemIconData.fromMap(self.readValue() as! [String: Any])      
      default:
        return super.readValue(ofType: type)
      
    }
  }
}
private class ToolbarHostApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? SelectedToolbarItem {
      super.writeByte(128)
      super.writeValue(value.toMap())
    } else if let value = value as? ToolbarGroup {
      super.writeByte(129)
      super.writeValue(value.toMap())
    } else if let value = value as? ToolbarItem {
      super.writeByte(130)
      super.writeValue(value.toMap())
    } else if let value = value as? ToolbarItemIconData {
      super.writeByte(131)
      super.writeValue(value.toMap())
    } else {
      super.writeValue(value)
    }
  }
}

private class ToolbarHostApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return ToolbarHostApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return ToolbarHostApiCodecWriter(data: data)
  }
}

class ToolbarHostApiCodec: FlutterStandardMessageCodec {
  static let shared = ToolbarHostApiCodec(readerWriter: ToolbarHostApiCodecReaderWriter())
}

///Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol ToolbarHostApi {
  func setItems(items: [Any]) -> Bool
  func setSelected(item: ToolbarItem) -> Bool
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class ToolbarHostApiSetup {
  /// The codec used by ToolbarHostApi.
  static var codec: FlutterStandardMessageCodec { ToolbarHostApiCodec.shared }
  /// Sets up an instance of `ToolbarHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: ToolbarHostApi?) {
    let setItemsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.ToolbarHostApi.setItems", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setItemsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let itemsArg = args[0] as! [Any]
        let result = api.setItems(items: itemsArg)
        reply(wrapResult(result))
      }
    } else {
      setItemsChannel.setMessageHandler(nil)
    }
    let setSelectedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.ToolbarHostApi.setSelected", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSelectedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let itemArg = args[0] as! ToolbarItem
        let result = api.setSelected(item: itemArg)
        reply(wrapResult(result))
      }
    } else {
      setSelectedChannel.setMessageHandler(nil)
    }
  }
}

private func wrapResult(_ result: Any?) -> [String: Any?] {
  return ["result": result]
}

private func wrapError(_ error: FlutterError) -> [String: Any?] {
  return [
    "error": [
      "code": error.code,
      "message": error.message,
      "details": error.details
    ]
  ]
}
